// File: src/components/sections/content/search-forms/CountrySelect.tsx
// Last change: Added state cleanup and removed unused state

import React, { useState, useEffect, useRef } from 'react';
import { useLocationForm, Country } from './LocationContext';

interface CountrySelectProps {
  onCountrySelect: (countryCode: string, flagPath: string) => void;
  onNextFieldFocus?: () => void;
  initialValue?: string;
}

const CountrySelect: React.FC<CountrySelectProps> = ({
  onCountrySelect,
  onNextFieldFocus,
  initialValue = '',
}) => {
  // Core state management
  const { state, updateCountry, fetchCountries, filterCountries, getFlagPath } = useLocationForm();
  const [input, setInput] = useState(initialValue.toUpperCase());
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState<number | null>(null);
  const [isInputFocused, setIsInputFocused] = useState(false);

  // DOM References
  const inputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const optionsRef = useRef<(HTMLLIElement | null)[]>([]);

  // Initial data fetch
  useEffect(() => { fetchCountries(); }, [fetchCountries]);

  // Get valid first characters from available countries
  const getValidFirstChars = (): Set<string> => {
    return new Set(state.countries.all.map(country => country.code_2[0]));
  };

  // Handle clicks outside the component
  useEffect(() => {
    const closeDropdown = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsDropdownOpen(false);
        setHighlightedIndex(null);
      }
    };

    document.addEventListener('mousedown', closeDropdown);
    return () => document.removeEventListener('mousedown', closeDropdown);
  }, []);

  // Core input handler with immediate selection for unique matches
  const handleInputChange = (newInput: string) => {
    // Clean and normalize input
    const cleanInput = newInput.replace(/[^A-Za-z]/g, '').toUpperCase();
    
    // Handle empty input - clear everything
    if (cleanInput.length === 0) {
      setInput('');
      onCountrySelect('', '');
      filterCountries('');
      setIsDropdownOpen(false);
      return;
    }

    // Validate first character
    if (cleanInput.length === 1) {
      const validFirstChars = getValidFirstChars();
      if (!validFirstChars.has(cleanInput)) {
        return;
      }
    }

    // Update input state and filter countries
    setInput(cleanInput);
    filterCountries(cleanInput);
    
    // Check filtered results after filtering
    const filteredCountries = state.countries.all.filter(c => 
      c.code_2.startsWith(cleanInput)
    );
    
    // Auto-select if only one country matches
    if (filteredCountries.length === 1) {
      selectCountry(filteredCountries[0]);
      return;
    }

    // Update UI state for multiple matches
    setIsDropdownOpen(true);
    setHighlightedIndex(null);
  };

  // Country selection handler
  const selectCountry = (country: Country) => {
    const flagPath = getFlagPath(country.code_2);
    
    // Update all states
    setInput(country.code_2);
    setIsDropdownOpen(false);
    setHighlightedIndex(null);
    setIsInputFocused(false);
    
    // Update context and parent
    updateCountry(country.code_2, flagPath, country.name_en);
    onCountrySelect(country.code_2, flagPath);
    
    // Move focus to postal code field
    if (onNextFieldFocus) {
      setTimeout(onNextFieldFocus, 0);
    }
  };

  // Keyboard navigation handler
  const handleKeyDown = (event: React.KeyboardEvent) => {
    // Handle dropdown-closed state
    if (!isDropdownOpen && (event.key === 'ArrowDown' || event.key === 'Enter')) {
      event.preventDefault();
      setIsDropdownOpen(true);
      setHighlightedIndex(0);
      setIsInputFocused(false);
      return;
    }

    if (!isDropdownOpen) return;

    const ITEMS_PER_PAGE = 8;
    const maxIndex = state.countries.filtered.length - 1;
    const currentIndex = highlightedIndex ?? 0;

    switch(event.key) {
      case 'ArrowDown':
        event.preventDefault();
        if (isInputFocused) {
          setIsInputFocused(false);
          setHighlightedIndex(0);
        } else {
          setHighlightedIndex(currentIndex >= maxIndex ? 0 : currentIndex + 1);
        }
        break;

      case 'ArrowUp':
        event.preventDefault();
        if (!isInputFocused && (highlightedIndex === 0 || highlightedIndex === null)) {
          setIsInputFocused(true);
          setHighlightedIndex(null);
        } else {
          setHighlightedIndex(currentIndex <= 0 ? maxIndex : currentIndex - 1);
        }
        break;

      case 'PageDown':
        event.preventDefault();
        setHighlightedIndex(Math.min(currentIndex + ITEMS_PER_PAGE, maxIndex));
        setIsInputFocused(false);
        break;

      case 'PageUp':
        event.preventDefault();
        setHighlightedIndex(Math.max(currentIndex - ITEMS_PER_PAGE, 0));
        setIsInputFocused(false);
        break;

      case 'Enter':
        event.preventDefault();
        if (highlightedIndex !== null && !isInputFocused) {
          selectCountry(state.countries.filtered[highlightedIndex]);
        }
        break;

      case 'Escape':
        event.preventDefault();
        setIsDropdownOpen(false);
        setHighlightedIndex(null);
        setIsInputFocused(true);
        inputRef.current?.focus();
        break;
    }
  };

  // Handle scroll behavior for keyboard navigation
  useEffect(() => {
    if (highlightedIndex !== null && !isInputFocused && isDropdownOpen) {
      optionsRef.current[highlightedIndex]?.scrollIntoView({
        block: 'nearest',
        behavior: 'smooth'
      });
    }
  }, [highlightedIndex, isInputFocused, isDropdownOpen]);

  return (
    <div className="country-select" ref={dropdownRef}>
      <div className="combobox-input-group">
        <input
          ref={inputRef}
          type="text"
          value={input}
          onChange={e => handleInputChange(e.target.value)}
          onKeyDown={handleKeyDown}
          onFocus={() => {
            setIsInputFocused(true);
            setIsDropdownOpen(true);
          }}
          placeholder="CC"
          maxLength={2}
          className="country-code-input"
        />
        <button
          type="button"
          className="dropdown-toggle"
          onClick={() => setIsDropdownOpen(!isDropdownOpen)}
          aria-label="Toggle country list"
          aria-expanded={isDropdownOpen}
        >
          <svg 
            width="10" 
            height="6" 
            viewBox="0 0 10 6" 
            fill="none" 
            xmlns="http://www.w3.org/2000/svg"
            style={{ 
              transform: `rotate(${isDropdownOpen ? 180 : 0}deg)`,
              transition: "transform 0.2s ease-in-out"
            }}
            aria-hidden="true"
          >
            <path 
              d="M1 1L5 5L9 1" 
              stroke="currentColor"
              strokeWidth="2" 
              strokeLinecap="round" 
              strokeLinejoin="round"
            />
          </svg>
        </button>

        {isDropdownOpen && (
          <ul className="combobox-options" role="listbox">
            {state.countries.filtered.map((country, index) => (
              <li
                key={country.code_2}
                ref={el => optionsRef.current[index] = el}
                onClick={() => selectCountry(country)}
                onKeyDown={handleKeyDown}
                className={`combobox-option ${
                  index === highlightedIndex && !isInputFocused ? 'highlighted' : ''
                }`}
                role="option"
                tabIndex={index === highlightedIndex && !isInputFocused ? 0 : -1}
                aria-selected={index === highlightedIndex}
              >
                <img
                  src={getFlagPath(country.code_2)}
                  alt={`${country.code_2} flag`}
                  className="country-flag-small"
                />
                <span className="country-code">{country.code_2}</span>
                <span className="country-separator">&nbsp;-&nbsp;</span>
                <span className="country-name">{country.name_en}</span>
                <span className="country-local text-gray-500">
                  &nbsp;({country.name_local})
                </span>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
};

export default CountrySelect;


// File: src/components/sections/content/search-forms/PostalCitySelect.tsx
// Last change: Applied working patterns from CountrySelect

import React, { useRef, useEffect, useState, RefObject } from "react";
import { useLocationForm, LocationSuggestion } from "./LocationContext";

interface PostalCitySelectProps {
  postalCodeRef?: RefObject<HTMLInputElement>;
  dateInputRef?: RefObject<HTMLInputElement>;
  onValidSelection: () => void;
}

const PostalCitySelect: React.FC<PostalCitySelectProps> = ({
  postalCodeRef,
  dateInputRef,
  onValidSelection,
}) => {
  const {
    state,
    updatePostalCode,
    updateCity,
    handleSuggestionSelect
  } = useLocationForm();

  // Local state
  const [input, setInput] = useState('');
  const [isDropdownOpen, setIsDropdownOpen] = useState(false);
  const [highlightedIndex, setHighlightedIndex] = useState<number | null>(null);
  const [isInputFocused, setIsInputFocused] = useState(true);
  const [page, setPage] = useState(1);

  // DOM References
  const inputRef = useRef<HTMLInputElement>(null);
  const cityInputRef = useRef<HTMLInputElement>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const optionsRef = useRef<(HTMLLIElement | null)[]>([]);

  // Constants
  const ITEMS_PER_PAGE = 20;
  const suggestions = state.validation.suggestions || [];
  const visibleSuggestions = suggestions.slice(0, page * ITEMS_PER_PAGE);
  const hasMore = suggestions.length > visibleSuggestions.length;

  // Handle input change
  const handleInputChange = (value: string) => {
    setInput(value);
    updatePostalCode(value);
    setIsDropdownOpen(true);
    setPage(1);
  };

  // Handle selection
  const handleSelection = async (suggestion: LocationSuggestion) => {
    await handleSuggestionSelect(suggestion);
    setIsDropdownOpen(false);
    setHighlightedIndex(null);
    setIsInputFocused(true);
    
    if (suggestion && dateInputRef?.current) {
      dateInputRef.current.focus();
      onValidSelection();
    }
  };

  // Handle keyboard navigation
  const handleKeyDown = (event: React.KeyboardEvent) => {
    // Ak nie je otvorený dropdown a stlačíme šípku dole alebo Enter
    if (!isDropdownOpen && (event.key === 'ArrowDown' || event.key === 'Enter')) {
      event.preventDefault();
      setIsDropdownOpen(true);
      setHighlightedIndex(0);
      setIsInputFocused(false);
      return;
    }

    if (!isDropdownOpen) return;

    const totalItems = visibleSuggestions.length + (hasMore ? 1 : 0);
    const maxIndex = totalItems - 1;

    switch(event.key) {
      case 'ArrowDown':
        event.preventDefault();
        if (isInputFocused) {
          setIsInputFocused(false);
          setHighlightedIndex(0);
        } else {
          setHighlightedIndex(prev => 
            prev === null || prev >= maxIndex ? 0 : prev + 1
          );
        }
        break;

      case 'ArrowUp':
        event.preventDefault();
        if (!isInputFocused && (highlightedIndex === 0 || highlightedIndex === null)) {
          setIsInputFocused(true);
          setHighlightedIndex(null);
          inputRef.current?.focus();
        } else {
          setHighlightedIndex(prev =>
            prev === null || prev <= 0 ? maxIndex : prev - 1
          );
        }
        break;

      case 'Enter':
        event.preventDefault();
        if (highlightedIndex !== null && !isInputFocused) {
          if (highlightedIndex === visibleSuggestions.length && hasMore) {
            setPage(p => p + 1);
          } else if (visibleSuggestions[highlightedIndex]) {
            handleSelection(visibleSuggestions[highlightedIndex]);
          }
        }
        break;

      case 'Escape':
        event.preventDefault();
        setIsDropdownOpen(false);
        setHighlightedIndex(null);
        setIsInputFocused(true);
        inputRef.current?.focus();
        break;
    }
  };

  // Handle scroll into view
  useEffect(() => {
    if (highlightedIndex !== null && !isInputFocused && isDropdownOpen) {
      optionsRef.current[highlightedIndex]?.scrollIntoView({
        block: 'nearest',
        behavior: 'smooth'
      });
    }
  }, [highlightedIndex, isInputFocused, isDropdownOpen]);

  return (
    <div className="location-search" ref={dropdownRef}>
      <div className="location-inputs">
        <div className="postal-code-wrapper">
          <input
            type="text"
            value={state.postalCode}
            onChange={(e) => handleInputChange(e.target.value)}
            onKeyDown={handleKeyDown}
            onFocus={() => {
              setIsInputFocused(true);
              setIsDropdownOpen(true);
            }}
            placeholder="Postal code"
            autoComplete="off"
            className="postal-input"
            ref={postalCodeRef || inputRef}
          />
          
          {isDropdownOpen && visibleSuggestions.length > 0 && (
            <ul className="search-results">
              {visibleSuggestions.map((suggestion, index) => (
                <li
                  key={`${suggestion.countryCode}-${suggestion.postalCode}-${suggestion.city}-${index}`}
                  ref={el => optionsRef.current[index] = el}
                  onClick={() => handleSelection(suggestion)}
                  onKeyDown={handleKeyDown}
                  className={`result-item ${index === highlightedIndex && !isInputFocused ? 'highlighted' : ''}`}
                  tabIndex={index === highlightedIndex && !isInputFocused ? 0 : -1}
                >
                  <img
                    src={suggestion.flagUrl}
                    alt={`${suggestion.countryCode} flag`}
                    className="country-flag-small"
                    onError={(e) => {
                      e.currentTarget.style.display = "none";
                    }}
                  />
                  <span className="postal-code">{suggestion.postalCode}</span>
                  <span className="city-name">{suggestion.city}</span>
                </li>
              ))}
              {hasMore && (
                <li
                  ref={el => optionsRef.current[visibleSuggestions.length] = el}
                  onClick={() => setPage(p => p + 1)}
                  className={`load-more ${visibleSuggestions.length === highlightedIndex && !isInputFocused ? 'highlighted' : ''}`}
                  tabIndex={visibleSuggestions.length === highlightedIndex && !isInputFocused ? 0 : -1}
                >
                  Load more results...
                </li>
              )}
            </ul>
          )}
        </div>
        <input
          type="text"
          value={state.city}
          onChange={(e) => updateCity(e.target.value)}
          placeholder="City"
          autoComplete="off"
          className="city-input"
          ref={cityInputRef}
        />
      </div>
    </div>
  );
};

export default PostalCitySelect;

// File: src/components/sections/content/search-forms/LocationContext.tsx
// Last change: Added pagination and enhanced validation logic

import { createContext, useState, useCallback, useContext, ReactNode, useRef } from 'react';

export interface Country {
  code_2: string;
  name_en: string;
  name_local: string;
  name_sk: string;
}

export interface LocationSuggestion {
  countryCode: string;
  postalCode: string;
  city: string;
  flagUrl: string;
}

interface LocationState {
  country: {
    code: string;
    flag: string;
    name?: string;
  };
  postalCode: string;
  city: string;
  validation: {
    isValidating: boolean;
    error: string | null;
    isDirty: boolean;
    isValid: boolean;
    suggestions?: LocationSuggestion[];
  };
  countries: {
    all: Country[];
    filtered: Country[];
    isLoading: boolean;
  };
  pagination: {
    offset: number;
    limit: number;
    total: number;
  };
}

interface ValidationResponse {
  isValid: boolean;
  error?: string;
  suggestions?: LocationSuggestion[];
  total?: number;
}

interface LocationFormContextValue {
  state: LocationState;
  updateCountry: (code: string, flag: string, name?: string) => void;
  updatePostalCode: (code: string) => Promise<void>;
  updateCity: (city: string) => Promise<void>;
  resetForm: () => void;
  clearValidation: () => void;
  handleSuggestionSelect: (suggestion: LocationSuggestion) => Promise<void>;
  fetchCountries: () => Promise<void>;
  filterCountries: (input: string) => void;
  getFlagPath: (countryCode: string) => string;
  loadMoreSuggestions: () => Promise<void>;
}

const getFlagPath = (countryCode: string): string =>
  `/flags/4x3/optimized/${countryCode.toLowerCase()}.svg`;

const initialState: LocationState = {
  country: {
    code: '',
    flag: '',
    name: '',
  },
  postalCode: '',
  city: '',
  validation: {
    isValidating: false,
    error: null,
    isDirty: false,
    isValid: false,
    suggestions: [],
  },
  countries: {
    all: [],
    filtered: [],
    isLoading: false,
  },
  pagination: {
    offset: 0,
    limit: 20,
    total: 0
  }
};

export const LocationFormContext = createContext<LocationFormContextValue | undefined>(undefined);

interface LocationFormProviderProps {
  children: ReactNode;
  type: 'pickup' | 'delivery';
}

export function LocationFormProvider({ children }: LocationFormProviderProps) {
  const [state, setState] = useState<LocationState>(initialState);
  const abortControllerRef = useRef<AbortController | null>(null);

  const updateValidation = useCallback((validation: Partial<LocationState['validation']>) => {
    setState((prev) => ({
      ...prev,
      validation: {
        ...prev.validation,
        ...validation,
      },
    }));
  }, []);

  const validateLocation = useCallback(
    async (postalCode: string, city: string, signal?: AbortSignal): Promise<ValidationResponse> => {
      try {
        const params = new URLSearchParams();
        params.append("postalCode", postalCode);
        params.append("city", city);
        if (state.country.code) {
          params.append("countryCode", state.country.code);
        }
        params.append("offset", state.pagination.offset.toString());
        params.append("limit", state.pagination.limit.toString());

        const response = await fetch(`/api/geo/location?${params.toString()}`, { signal });
        const data = await response.json();
        
        return {
          isValid: data.results && data.results.length > 0,
          suggestions: data.results.map((result: any) => ({
            countryCode: result.country_code,
            postalCode: result.postal_code,
            city: result.place_name,
            flagUrl: result.flag_url,
          })),
          total: data.total
        };
      } catch (error) {
        if ((error as any).name === "AbortError") {
          return { isValid: false, suggestions: [] };
        }
        console.error("Validation error:", error);
        return { isValid: false, error: "Validation failed" };
      }
    },
    [state.country.code, state.pagination.offset, state.pagination.limit]
  );

  const loadMoreSuggestions = useCallback(async () => {
    const newOffset = state.pagination.offset + state.pagination.limit;
    
    try {
      const validationResult = await validateLocation(state.postalCode, state.city);
      
      setState(prev => ({
        ...prev,
        validation: {
          ...prev.validation,
          suggestions: [
            ...(prev.validation.suggestions || []),
            ...(validationResult.suggestions || [])
          ]
        },
        pagination: {
          ...prev.pagination,
          offset: newOffset,
          total: validationResult.total || prev.pagination.total
        }
      }));
    } catch (error) {
      console.error("Load more error:", error);
    }
  }, [state.pagination, state.postalCode, state.city, validateLocation]);

  const fetchCountries = useCallback(async () => {
    if (state.countries.all.length > 0 || state.countries.isLoading) return;

    setState((prev) => ({
      ...prev,
      countries: { ...prev.countries, isLoading: true },
    }));

    try {
      const response = await fetch('/api/geo/countries');
      if (!response.ok) throw new Error('Failed to fetch countries');
      const data: Country[] = await response.json();
      const sortedData = data.sort((a, b) => a.code_2.localeCompare(b.code_2));
      setState((prev) => ({
        ...prev,
        countries: {
          all: sortedData,
          filtered: sortedData,
          isLoading: false,
        },
      }));
    } catch (error) {
      console.error("Country loading error:", error);
      setState((prev) => ({
        ...prev,
        countries: {
          ...prev.countries,
          isLoading: false,
        },
      }));
    }
  }, [state.countries.all.length, state.countries.isLoading]);

  const filterCountries = useCallback((input: string) => {
    setState((prev) => ({
      ...prev,
      countries: {
        ...prev.countries,
        filtered: prev.countries.all.filter((country) =>
          country.code_2.startsWith(input.toUpperCase())
        ),
      },
    }));
  }, []);

  const updateCountry = useCallback((code: string, flag: string, name?: string) => {
    setState((prev) => ({
      ...prev,
      country: { code, flag, name },
      validation: {
        ...initialState.validation,
        isDirty: true,
      },
      pagination: {
        ...initialState.pagination
      }
    }));
  }, []);

  const updatePostalCode = useCallback(async (code: string) => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    const controller = new AbortController();
    abortControllerRef.current = controller;

    setState((prev) => ({
      ...prev,
      postalCode: code,
      validation: {
        ...prev.validation,
        isDirty: true,
        isValidating: true,
        error: null,
        suggestions: [],
      },
      pagination: {
        ...initialState.pagination
      }
    }));

    if (code.trim() === "") {
      updateValidation({
        isValidating: false,
        error: null,
        isValid: false,
        suggestions: [],
      });
      return;
    }

    const validationResult = await validateLocation(code, state.city, controller.signal);
    updateValidation({
      isValidating: false,
      error: validationResult.error || null,
      isValid: validationResult.isValid,
      suggestions: validationResult.suggestions,
    });
    
    setState(prev => ({
      ...prev,
      pagination: {
        ...prev.pagination,
        total: validationResult.total || 0
      }
    }));
  }, [state.city, validateLocation, updateValidation]);

  const updateCity = useCallback(async (city: string) => {
    setState((prev) => ({
      ...prev,
      city,
      validation: {
        ...prev.validation,
        isDirty: true,
        isValidating: true,
      },
      pagination: {
        ...initialState.pagination
      }
    }));
    
    const validationResult = await validateLocation(state.postalCode, city);
    updateValidation({
      isValidating: false,
      error: validationResult.error || null,
      isValid: validationResult.isValid,
      suggestions: validationResult.suggestions,
    });
    
    setState(prev => ({
      ...prev,
      pagination: {
        ...prev.pagination,
        total: validationResult.total || 0
      }
    }));
  }, [state.postalCode, validateLocation, updateValidation]);

  const handleSuggestionSelect = useCallback(async (suggestion: LocationSuggestion) => {
    setState((prev) => ({
      ...prev,
      postalCode: suggestion.postalCode,
      city: suggestion.city,
      validation: {
        ...prev.validation,
        isDirty: true,
        isValidating: true,
      },
    }));
    
    const validationResult = await validateLocation(suggestion.postalCode, suggestion.city);
    updateValidation({
      isValidating: false,
      error: validationResult.error || null,
      isValid: validationResult.isValid,
      suggestions: validationResult.suggestions,
    });
  }, [validateLocation, updateValidation]);

  const resetForm = useCallback(() => {
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    setState(initialState);
  }, []);

  const clearValidation = useCallback(() => {
    updateValidation(initialState.validation);
  }, [updateValidation]);

  const contextValue: LocationFormContextValue = {
    state,
    updateCountry,
    updatePostalCode,
    updateCity,
    resetForm,
    clearValidation,
    handleSuggestionSelect,
    fetchCountries,
    filterCountries,
    getFlagPath,
    loadMoreSuggestions
  };

  return (
    <LocationFormContext.Provider value={contextValue}>
      {children}
    </LocationFormContext.Provider>
  );
}

export function useLocationForm() {
  const context = useContext(LocationFormContext);
  if (!context) {
    throw new Error('useLocationForm must be used within LocationFormProvider');
  }
  return context;
}